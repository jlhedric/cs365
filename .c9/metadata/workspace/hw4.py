{"filter":false,"title":"hw4.py","tooltip":"/hw4.py","undoManager":{"mark":2,"position":2,"stack":[[{"group":"doc","deltas":[{"start":{"row":0,"column":0},"end":{"row":246,"column":7},"action":"insert","lines":["#!/usr/bin/env python3","\"\"\"","Author: Jade Hedrick","HW3 CS365 Forensics, Spring 2015","\"\"\"","import sys","from tags import TAGS","from struct import unpack","","","JPEG_HEADER = b'\\xff\\xd8'","","class exifDump:","","\tdef __init__(self, filename):","\t\tself.filename = filename","\t\tself.fd = self.open_file()","\t\tself.offset = 2","\t\tself.endian_offset = 0","","\tdef open_file(self):","\t    \"\"\" ","\t    Author: Brian Levine","\t    Opens filename, and calls usage() on error.","\t    Returns:","\t      an open file descriptor","\t    \"\"\"","","\t    try:","\t      return(open(self.filename, \"rb\"))","\t    except IOError as err:","\t      print(\"IOError opening file: \\n\\t%s\" % err)","\t      usage()","\t    except:","\t      print(\"Unexpected error:\", sys.exc_info()[0])","\t      usage()","","\tdef check_jpeg(self):","\t\t\"\"\"","\t\tChecks that the file is a JPEG. If it isn't, exits. ","\t\tElse, continues to find markers.","\t\t\"\"\"","\t\ttry:","\t\t\tdata = self.fd.read(2)","\t\texcept:","\t\t\tprint(\"Unexpected error while reading file:\", sys.exc_info()[0])","\t\t\tsys.exit()","\t\t#if not JPEG\t","\t\tif(data != JPEG_HEADER):","\t\t\tprint(\"Warning: File is not a JPEG. Program will now exit.\")","\t\t\tsys.exit()","\t\telse:","\t\t\tself.find_markers()","","\tdef find_markers(self):","\t\t\"\"\"","\t\tCycles through the metadata of the JPEG. Makes call to check_exif_and_endian()","\t\tfor each marker. ","\t\t\"\"\"","\t\tmarker_value = 0","\t\tmarker_location = 0","\t\tmarker_length = 0","\t\t#run until FFDA marker","\t\twhile marker_value != int.from_bytes(b'\\xFF\\xDA', byteorder='big'):","\t\t\tmarker_location = self.fd.tell()","\t\t\ttry:","\t\t\t\tmarker_value = unpack(\">H\", self.fd.read(2))[0]","\t\t\t\tmarker_length = unpack(\">H\", self.fd.read(2))[0]","\t\t\texcept:","\t\t\t\tprint(\"Unexpected error while reading markers:\", sys.exc_info()[0])","\t\t\tprint(\"[0x%04X]\" % marker_location, end = \" \")","\t\t\tprint(\"Marker 0x%04X\" % marker_value, end = \" \")","\t\t\tprint(\"size=0x%04X\" % marker_length)","\t\t\tself.check_exif_and_endian()","\t\t\tself.offset = marker_location + 2 + marker_length","\t\t\tself.fd.seek(self.offset)","","\tdef check_exif_and_endian(self):","\t\t\"\"\"","\t\tReads in first 6 bytes of marker headers. If exif, checks next 2 bytes for ","\t\tendianness. If big endian, make call to get_IFD(), otherwise exit.","\t\t\"\"\"\t","\t\ttry:\t","\t\t\tdata = self.fd.read(6)","\t\texcept:","\t\t\tprint(\"Unexpected read error while checking exif:\", sys.exc_info()[0])","\t\t#if exif","\t\tif(data == b'Exif\\x00\\x00'):","\t\t\tself.endian_offset = self.fd.tell()","\t\t\t#if big endian","\t\t\tif(self.fd.read(2) == b'MM'):","\t\t\t\t#skip over 00 2a","\t\t\t\tself.fd.read(2)","\t\t\t\tself.get_IFD()","\t\t\telse:","\t\t\t\tprint(\"Get back little endian scum! Program will exit for such insolence!\")","\t\t\t\tsys.exit()","","\tdef get_IFD(self):","\t\t\"\"\"","\t\tPrints number of IFD entries. Parses IFD tags with call to format().","\t\t\"\"\"","\t\tbytes_per_component = (0,1,1,2,4,8,1,1,2,4,8,4,8)","\t\ttry:","\t\t\tself.offset = unpack(\">L\", self.fd.read(4))[0]","\t\t\tself.fd.read(self.offset - 8)","\t\t\tnum_entries = unpack(\">H\", self.fd.read(2))[0]","\t\t\tprint(\"Number of IFD Entries: \", num_entries)","\t\texcept:","\t\t\tprint(\"Unexpected read error while fetching number of IFD entries:\", sys.exc_info()[0])","\t\t#for num_entries","\t\tfor num in range(0, num_entries):","\t\t\t#at this point we are at the beginning of an entry","\t\t\t#here we save an index pointing to the next entry 12 bytes away","\t\t\tnext_tag = self.fd.tell() + 12","\t\t\ttag = unpack(\">H\", self.fd.read(2))[0]","\t\t\tprint(\"%X\" % tag, end = \" \")","\t\t\tprint(TAGS[tag], end = \" \")","\t\t\tformat = unpack(\">H\", self.fd.read(2))[0]","\t\t\tnum_of_components = unpack(\">L\", self.fd.read(4))[0]","\t\t\tlength = bytes_per_component[format]*num_of_components","\t\t\tself.format(format, num_of_components, length)","\t\t\t#no matter where we got to in format(), we only jump 12 bytes from the start of the loop","\t\t\tself.fd.seek(next_tag)","\t\t\t# if(length <= 4):","\t\t\t# \t#WRONG","\t\t\t# \tdata = unpack(\">L\", self.fd.read(4))[0]","\t\t\t# \tprint(data)","\t\t\t# \t#WRONG","\t\t\t# else:","\t\t\t# \tdata = unpack(\">L\", self.fd.read(4))[0]","\t\t\t# \tnext_tag = self.fd.tell()","\t\t\t\t#move back to 0x4d","\t\t\t\t# self.fd.seek(self.endian_offset)","\t\t\t\t# #read up to the data offset","\t\t\t\t# self.fd.read(data)","\t\t\t\t# print(self.fd.read(length).decode(\"utf-8\").rjust(35))","\t\t\t\t# #go to the next tag","\t\t\t\t# self.fd.seek(next_tag)","","\t#the part where it stops looking pretty","\tdef format(self, format, num_of_components, length):","\t\tformat = format","\t\tlength = length","\t\tnumerator   = 1.0","\t\tdenominator = 1.0","\t\tif(format == 1):","\t\t\tif(length <= 4):","\t\t\t\tdata = unpack(\">B\", self.fd.read(1))[0]","\t\t\t\tprint(data)","\t\t\telse:","\t\t\t\tdata_offset = unpack(\">L\", self.fd.read(4))[0]","\t\t\t\t#move back to 0x4d","\t\t\t\tself.fd.seek(self.endian_offset)","\t\t\t\t#read up to the data offset","\t\t\t\tself.fd.read(data_offset)","\t\t\t\tdata = unpack(\">B\", self.fd.read(1))[0]","\t\t\t\tprint(data)","\t\telif(format == 2):","\t\t\tif(length <= 4):","\t\t\t\tdata = bytes.decode(self.fd.read(1))","\t\t\t\tprint(data)","\t\t\telse:","\t\t\t\tdata_offset = unpack(\">L\", self.fd.read(4))[0]","\t\t\t\t#move back to 0x4d","\t\t\t\tself.fd.seek(self.endian_offset)","\t\t\t\t#read up to the data offset","\t\t\t\tself.fd.read(data_offset)","\t\t\t\tdata = bytes.decode(self.fd.read(length))","\t\t\t\tprint(data)","\t\telif(format == 3):","\t\t\tif(length <= 4):","\t\t\t\tdata = unpack(\">%dH\" % num_of_components, self.fd.read(length))[0]","\t\t\t\tprint(data)","\t\t\telse:","\t\t\t\tdata_offset = unpack(\">L\", self.fd.read(4))[0]","\t\t\t\t#move back to 0x4d","\t\t\t\tself.fd.seek(self.endian_offset)","\t\t\t\t#read up to the data offset","\t\t\t\tself.fd.read(data_offset)","\t\t\t\tdata = unpack(\">%dH\" % num_of_components, self.fd.read(length))[0]","\t\t\t\tprint(data)","\t\telif(format == 4):","\t\t\tif(length <= 4):","\t\t\t\tdata = unpack(\">L\", self.fd.read(4))[0]","\t\t\t\tprint(data)","\t\t\telse:","\t\t\t\tdata_offset = unpack(\">L\", self.fd.read(4))[0]","\t\t\t\t#move back to 0x4d","\t\t\t\tself.fd.seek(self.endian_offset)","\t\t\t\t#read up to the data offset","\t\t\t\tself.fd.read(data_offset)","\t\t\t\tdata = unpack(\">L\", self.fd.read(4))[0]","\t\t\t\tprint(data)","\t\telif(format == 5):","\t\t\tif(length <= 4):","\t\t\t\t(numerator, denominator) = unpack(\">LL\", self.fd.read(8))[0]","\t\t\t\tprint(\"%s/%s\" % (numerator, denominator))","\t\t\telse:","\t\t\t\tdata_offset = unpack(\">L\", self.fd.read(4))[0]","\t\t\t\t#move back to 0x4d","\t\t\t\tself.fd.seek(self.endian_offset)","\t\t\t\t#read up to the data offset","\t\t\t\tself.fd.read(data_offset)","\t\t\t\t(numerator, denominator) = unpack(\">LL\", self.fd.read(8))[0]","\t\t\t\tprint(\"%s/%s\" % (numerator, denominator))","\t\telif(format == 7):","\t\t\tif(length <= 4):","\t\t\t\tvalue = unpack(\">%dB\" % length, self.fd.read(length))[0]","\t\t\t\tdata = \"\".join(\"%c\" % x for x in value)","\t\t\t\tprint(data)","\t\t\telse:","\t\t\t\tdata_offset = unpack(\">L\", self.fd.read(4))[0]","\t\t\t\t#move back to 0x4d","\t\t\t\tself.fd.seek(self.endian_offset)","\t\t\t\t#read up to the data offset","\t\t\t\tself.fd.read(data_offset)","\t\t\t\tvalue = unpack(\">%dB\" % length, self.fd.read(length))[0]","\t\t\t\tdata = \"\".join(\"%c\" % x for x in value)","\t\t\t\tprint(data)","","def usage():","\t\"\"\"","\tCatches error when arguments are not valid","\t\"\"\"","\tprint(\"Error: \\n\")","\tprint(\"Usage: hw3.py filename\")","","def main():\t","\t\"\"\"","\tReads in filename argument.","\t\"\"\"","\tif len(sys.argv) == 2:","\t\ttry:","\t\t\tfilename = sys.argv[1]","\t\texcept:","\t\t\tprint(\"Unexpected error while reading argument:\", sys.exc_info()[0])","\t\t\tsys.exit()","\t\t#make call to main class","\t\tfile = exifDump(filename)","\t\tfile.check_jpeg()","\telse:","\t\tusage()","","","if __name__ == '__main__':","\tmain()"]}]}],[{"group":"doc","deltas":[{"start":{"row":3,"column":2},"end":{"row":3,"column":3},"action":"remove","lines":["3"]}]}],[{"group":"doc","deltas":[{"start":{"row":3,"column":2},"end":{"row":3,"column":3},"action":"insert","lines":["4"]}]}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":3,"column":3},"end":{"row":3,"column":3},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1426186073174,"hash":"7481317c4dbd6917f96b7819cddf64038d348345"}